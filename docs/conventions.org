* Conventions in Emtest
** Headers
*** Purpose

To record, design, and describe conventions related to Emtest.

*** State

Copied in from elsewhere

** Body

*** Conventions
(Meta: This is about Elisp test code)
**** Names of test helpers and test data

|------------------+---------------|
| Type of thing    | Form of name  |
|------------------+---------------|
| Test helper      | Base:th:X     |
| Test data object | Base:thd:X    |
| Test supporter   | Base:ts:X     |
| Test environment | Base:th:env:X |
| Bindings         | Base:th:let:X |
| Operation        | Base:th:op:X  |
|------------------+---------------|

***** Arglists

If there are any optional parameters, the first argument is a keylist
of all optional parameters.  Usually the rest of the args are body.

In Elisp, be sure to use cl's `defun*' or `defmacro*' to allow
keylists.

***** Confession

My older test-helpers sometimes violate these style guidelines.  They
are from a time when I was exploring and developing them.


**** Test objects with canonical meanings

I found that if certain objects have consistent canonical meanings, it
makes testing easier to see at a glance.  I use:

 * 12 :: A value to be tested against, or an object that correctly
         matches it.
 * 144, 1728 :: Other correct values, as needed
 * 13 :: An object that does not correctly match something.

**** Where test-related files go

***** Early idea, only relevant to data files
   * (No) t/  Not quite right.  That's test files to be run.  
   * (No) examples/ No.  That's example files, not files of examples
   * (Chosen) t/data/, a subdiectory of t.

***** Types of files
Relation ranges over:

 * tests :: tests themselves
 * examples ::  A directory of ordinary files used in tests.
 * testhelp :: Test helpers.  Ie, functions that would belong in "foo"
   library except that their only purpose is to help foo's callers
   test foo-related things.
   * Test data.  A sub-type of test helper; should be grouped with it.
 * typeextras :: Type extras.  Eg type predicates.  These generally
   use deep-type-checker.el, so should be separate.
 * Pcomplete :: editing help via pcomplete.
 * editing :: General editing help

***** Approaches

****** Template

These examples are shown under each approach:

|-----------+--------------+-----------|
| Relation  | Library path | Extra     |
|-----------+--------------+-----------|
| Tests     | foo.el       |           |
| Test help | foo.el       |           |
| Test help | dir1/bar.el  |           |
| Examples  | dir1/bar.el  | file1.txt |
|           |              |           |
|-----------+--------------+-----------|

****** LEANING_TOWARDS In Path/Relation/Extra
  * Con: Disagrees with the t/ convention
  * Con: Having a lot of files called "tests.el" (etc) may be
    confusing.
  * Pro: Puts a library and its support all under the same prefix.
  * Examples:
    * foo/tests.el
    * foo/testhelp.el
    * dir1/bar/testhelp.el
    * dir1/bar/examples/file1.txt

****** MAYBE In Dirpath/Relation/Basename/Extra
  * Con: Splits the path, which is slightly more complex.
  * Pro: File trees are often in fact organized this way, seems to
    work reasonably well.

  * Examples:
    * foo/tests.el
    * foo/testhelp.el
    * dir1/testhelp/bar.el
    * dir1/examples/bar/file1.txt

****** NOT_CHOSEN In /t/Relation/Path/Extra

 * Con: The t/ convention is hinted at but not actually obeyed.

 * Examples:
   * t/tests/foo.el
   * t/testhelp/foo.el
   * t/testhelp/dir1/bar.el
   * t/examples/dir1/file1.txt

****** NOT_CHOSEN In /Relation/Path/Extra

And "test" is called "t".
 * Con: Won't ever be able to subdivide a relation, eg
   "testhelp/data/" because that would keep files from being found.
 * Con: Subpackage boundaries make it unclear where root should be.

 * Examples:
   * t/foo.el
   * testhelp/foo.el
   * testhelp/dir1/bar.el
   * examples/dir1/file1.txt

***** And to support t/

There could also be a prefix that's covariant with relation.  For
tests at least it would be t/.

But that's essentially the same as just adding */t/ to the load-path.
So we do nothing special.

**** Directory organizing principles
(Meta: Not really a convention, but related)

 * Libraries are grouped under directories when the grouping is
   natural.  For instance:
   * Part of the same package
   * The group's functionality is well distinct from outside
     functionality.
 * A library L1 is subordinated to another library L0 if L1 augments
   L0 in a way that doesn't give L1 an independent identity.  Common
   cases: 
   * L1 has a canonical supporting role, eg:
     * tests
     * testhelp (code provided by L1 for tests beyond its own tests)
     * info
   * L1 supports L0 in a role established by a third package, eg:
     * pcomplete
     * font-lock
     * skeleton

**** Directories in Emtest

Plan of lisp directories for Emtest: 
 * emtest ::
   * runner :: The test runner in Elisp
   * testhelp :: code not required in emtest but useful in writing
                 tests in Elisp
     * Note "standard", which should probably be loaded more
       aggressively than the others.  
       * Perhaps whenever define is loaded, but let's keep 'em separate
         to leave some flexibility.
   * testhelp/mocks :: Mocks of specific functionality
   * common :: Code shared by viewer and Elisp tester.
   * viewer :: Formatting & display code specific to Emtest
   * editing :: Help for writing and editing elisp tests in emacs.
     * When the editing is specific to some file FOO, it should go in
       FOO/editing.el 
   * persistence :: Code dealing with persistence
 * viewers :: Libraries that provide viewer functionality
 * utility :: Generally useful support code originally developed for
                Emtest.

***** Considerations
****** Naming
 * emtest ::
   * runner :: The test runner in Elisp
     * Maybe rename this 
       * NO emtest?  
       * NO test-runner?  
       * NO eltest?  
       * elisp-test?
       * test-elisp
       * tester
   * testhelp :: 
     * Might be moved to just testhelp/
   * testhelp/mocks :: 
   * common :: 
     * Maybe rename this "both"? "all"?
     * "shared"
   * viewer :: 
   * editing :: 
     * Was named "editor"
     * May belong under "runner", since it only applies to elisp
       tests.
   * persistence :: 
 * viewers :: 
   * "viewer"?
   * "insert"?
   * "inserter"?
   * "format"?
   * Moved anyways
 * utility :: 
   * Maybe rename it "internal"?  "support"?  "infrastructure"?
     "utility" once that name is vacated.
   * Was named "compiling" but that was misleading.
   * Moved

**** Names of elisp objects

The prefix abbreviates a longer path
 * emt :: Entry points
     * Test launch commands
     * Test definition commands
     * Standard testhelp (Maybe)
 * Common types :: 
   * emt:testral :: emtest/common/testral-types
   * emt:result :: Suggested for some of emtest/common/testral-types
                   to distinguish it from TESTRAL notes
   * emthow :: emtest/common/results-types but is just part and will move.
   * emtt :: Also in emtest/common/results-types
 * Runner :: 
   * emtt :: emtest/runner/tester 
   * emtt :: emtest/runner/explorers/*
     * Same as tester
   * emtl :: emtest/runner/launch (Other than entry points)
   * emtd :: emtest/runner/define (Other than entry points)
   * emts :: emtest/runner/surrounders
   * emti :: emtest/runner/individual
 * Testhelp :: 
   * emth :: emtest/runner/testhelp/standard (Other than entry points)
   * emth :: emtest/testhelp/misc
     * Same as standard
     * This and standard could stand being reorganized
       * Equality-like compares (and tree stuff)
       * Did it throw/error checks
       * Insulation/let-like stuff
       * Doc stuff
	 * Including map&trap & other disassembling
   * emt:persist :: emtest/tester/testhelp/persist
     * The sole function here is a common entry point
   * emtg :: emtest/testhelp/tagnames
     * Was emt:eg
   * emtm :: emtest/testhelp/match
   * emtp :: emtest/testhelp/testpoint
   * emty :: emtest/testhelp/deep-type-checker
   * emtmd :: emtest/testhelp/mocks/dirtree
   * emtmk :: emtest/testhelp/mocks/keystuffer
   * emtmvc :: emtest/testhelp/mocks/ specific to version control
   * emtmvc:git :: emtest/testhelp/mocks/git
   * emtb :: emtest/testhelp/mocks/filebuf
 * Editing :: 
   * emter :: emtest/editing/trail
   * emt:insert :: emtest/editing/insert
     * The one prominent one is an entry point.  The others have the
       same prefix.
   * emtel :: emtest/editing/lisp
     * Doesn't exist yet
   * emtvers :: emtest/editing/versioning
 * emtv? :: Viewer in general
   * emtve :: emtest/viewers/emviewer
   * emtv2 :: emtest/viewers/emviewer2
   * emtvf :: emtest/viewers/emformat
   * emtvr :: emtest/viewers/receive
   * emtvr :: emtest/viewers/view-types also
 * emt:db :: emtest/common/persist (Obsolete)
 * emt:db:view :: emtest/common/persist stuff that wants to be moved
                  to viewer.
 * emdb :: New persistence, emtest/common/persist-2
   * emdb:tinydb :: Persistence stuff specifically working with tinydb 
 * (Nothing in common) :: Viewer in general
   * hiformat :: emtest/viewers/hiformat
   * wookie :: emtest/viewers/wookie
   * chewie :: emtest/viewers/chewie
   * wysiwyg :: emtest/viewers/wysiwyg
   * Change to vwr?  To fmt?
 * Utility ::
   * pending :: utility/pending
   * loal :: utility/loal
   * utifld :: utility/field
   * utim :: utility/misc
     * utim:get-properties
     * Not created yet
   * align-lists :: utility/align-lists
   * utiacc :: utility/accumulator
   * emtvp :: utility/pathtree
   * ttvtable :: utility/ttvtable Type-tag dispatch table
   * utiuid :: utility/uuid

***** Some replacements done
("emth:flet-unbound" "emt:flet-unbound" "emth:let-unbound" "emt:let-unbound" "emth:let-noprops" "emt:let-noprops" "emth:collect-in-tree" "emt:collect-in-tree" "emth:somewhere-in-tree" "emt:somewhere-in-tree" "emth:all-different" "emt:util:all-different" "emth:sets=" "emt:sets=" "emth:bags=" "emt:bags=" "emth:assert-throws" "emt:assert-throws" "emth:throws" "emt:throws" "emth:throws-x" "emt:throws-x" "emth:example-error" "emtg:example-error" "emth:gives-error" "emt:gives-error" "emtg" "emt:eg" "emtg:example" "emt:example")
("emth:trap-errors" "emtt:trap-errors" "emts:add-surrounders" "emtt:add-surrounders" "emtb:with-file-f" "with-file-containing" "emtb:with-buf-f" "with-buffer-containing-buildform" "emtb:with-buf" "with-buffer-containing-object" "emthow" "emt:test-ID:e-n" "emt:db:view:accept-correct" "emt:persist:accept-correct" "emt:db:view:extract" "emt:db:extract-got" "emtdb:view:view-obj" "emt:persist:view-obj" "emt:db:single-value" "emt:db:persist:value" "emt:db:persist:value" "emt:persist:value" "emt:db:extract-got" "emt:extract-got" "emter" "emt/trail" "emth:persist" "emt:persist" "emth:flet-unbound" "emt:flet-unbound")
**** Style for test docstrings 
***** Why

Test docstrings without a consistent style are a mess.  

Test docstrings without a consistent style are harder to read, because
they surprise you in ways that have nothing to do with their meaning.

Docstrings without a consistent style are also harder to construct.
You might not think so right away, because it takes some attention to
learn the style and start using it.  But once you know it, it's easier
to use it each time than to invent a way to describe each new test.

And because the style below is well tuned for tests, it can help you
think about what the test is doing.

***** Form

The simplest form of the docstrings is:

: "TYPE: Description."

where TYPE is one of the types listed below.  Example:

 : "Shows: It wraps the examples as expected."

Usually a docstring consists of several of the simple forms.  Example:

 : "Situation: A form that returns non-nil.
 : Response: Collect a passing grade."

If two or more descriptions follow the same type, the type need only
appear once.  Example:

 : "Situation: Suite has two clauses defined.  
 : Full exploration is enabled."

***** Canonical types
****** About types

The canonical types are slightly slippery and overlapping.  That's
accepted.  They exist to efficiently describe common testing
situations, not to taxonomize them.

****** List of canonical types

   * Situation :: What the situation is before the function in
                  question is called or the operation
   * Param :: A subtype of "Situation". It focusses on some specific
              parameter being passed to a function.  To be used when
              that parameter markedly affects the function's expected
              or potential behavior.

   * Operation :: A function whose behavior is being tested is called.
                  This type is *not* used when the function call is
                  obvious; that's unmarked.

		  Examples of testing situations it is intended for:

     * Several functions normally operate on this sort of situation at
       this level.
     * There is a single function of interest, but its behavior is so
       heterogeneous that it makes sense to focus on its different
       operations.
     * *Not* when there is only one function of interest and it's
       called in essentially the expected way.
   * Behavior :: A function's behavior.  Used in these ways:
     * To describe a function's behavior abstractly, while other
       documentation describes its effects concretely.
     * To describe the behavior of a marked operation (as opposed to
       an unmarked operation)
     * As "Behavior: As usual" to express still behaving normally even
       in a particular situation (Described separately by "Situation"
       or "Param")

   * Afterwards :: Describe the intended situation after the operation
                   has run.  Specifically about inspecting a situation
                   and not a return value or error signalled.

   * Response :: Abbreviates Unmarked Operation + (Behavior or
                 Afterwards).  Used when it doesn't create ambiguity
                 about what is being described.

     * Part of the most common pattern, Situation/Response.

   * Shows :: What the test demonstrates.  Intended for two
              situations:
       * When a test is so simple that it cannot reasonably be
         documented as situation/response or other patterns.  Used
         alone.
       * When other patterns apply but do not sufficiently describe
         what the test is demonstrating.  Used in conjunction with
         other docs.
   * Proves :: *Deprecated*; use "Shows" instead.  I used to use this
               until I realized that it's misleading.  Tests don't
               prove correctness, they show correct behavior.  It's a
               subtle point but one well worth keeping in mind.
   * Not tested :: A placeholder, usually for "Response".  Used when
                   test would have ideally checked some condition, but
                   that wasn't done for whatever reason.
   * Simple :: (New, untested) Indicates that a certain situation is
               realized by a simple means might not be realized so
               simply in practice.



***** Abstract and concrete

Often a test wants to be described on two levels: The abstract level
of what it proves, and the concrete level of the given example.

I just use a hyphen in between abstract and concrete descriptions.

I also tried "ie, ..." there.

***** Avoidance

Haven't entirely settled on a way to express negative conditions, like
still behaving right even in a situation where there's a particular
potential for bad behavior.  Eg, testing a list operation on a
circular list.

Perhaps
 * "Behavior: As usual"
 * "Behavior: Same"

***** Use of examples

Haven't settled on a way of describing "Behaves this way under
multiple examples".  No experience until I get emtest running and
seeing multiple results.

***** Issues

****** Nested use

As in trail.el.  This built a form and then evalled the result in
several different contexts.  I found I needed to specify a situation
and response for each such eval.

Not sure yet what works well for this.

